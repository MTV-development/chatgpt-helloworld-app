# Pomodoro Timer Widget - Implementation Plan

## Overview

Build a **visual Pomodoro timer widget** that showcases the core purpose of ChatGPT widgets: providing rich, interactive UI experiences beyond plain text responses.

### User Flow
1. User: "Start a pomodoro timer"
2. ChatGPT: "How many minutes would you like for your focus session?"
3. User: "25 minutes"
4. ChatGPT: Calls `start_pomodoro` tool → Widget displays visual countdown timer inline in conversation

---

## Background: ChatGPT Apps SDK

### What is the Apps SDK?

The [OpenAI Apps SDK](https://developers.openai.com/apps-sdk/) enables developers to extend ChatGPT with custom tools and rich UI components. Announced in September 2025, it builds on the **Model Context Protocol (MCP)**, the open standard that lets ChatGPT connect to external tools and data.

The Apps SDK extends MCP so developers can design both the **logic** (tools, data processing) and **interface** (widgets, visual components) of their apps. OpenAI has made the Apps SDK open source so that apps built with it can run anywhere that adopts this standard.

### Two-Component Architecture

To build an app for ChatGPT with the Apps SDK, you need two components:

1. **MCP Server** - Exposes your app's capabilities (tools) to ChatGPT using the Model Context Protocol. This is where you define what actions ChatGPT can take (e.g., `start_pomodoro`, `get_sales_dashboard`).

2. **Widget (Web Component)** - A web interface built with any framework (React, vanilla JS, etc.) that renders in an iframe within the ChatGPT interface. This displays your app's output and handles user interactions.

```
┌─────────────────────────────────────────────────────────────────┐
│                         ChatGPT                                  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    Conversation                            │  │
│  │  User: "Start a 25 minute timer"                          │  │
│  │                                                            │  │
│  │  ChatGPT: Calls start_pomodoro tool                       │  │
│  │           ↓                                                │  │
│  │  ┌─────────────────────────────────┐                      │  │
│  │  │     Widget (iframe)              │  ← Your UI          │  │
│  │  │     ┌─────────────────────┐     │                      │  │
│  │  │     │    Pomodoro Timer   │     │                      │  │
│  │  │     │       23:45         │     │                      │  │
│  │  │     └─────────────────────┘     │                      │  │
│  │  └─────────────────────────────────┘                      │  │
│  └───────────────────────────────────────────────────────────┘  │
│                              ↕                                   │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              MCP Server (your backend)                     │  │
│  │   Tools: start_pomodoro, get_sales_dashboard, etc.        │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### The window.openai API

When ChatGPT loads your widget in an iframe, it injects a `window.openai` object that serves as the bridge between your frontend and ChatGPT. This API provides:

**State & Data:**
| Property | Description |
|----------|-------------|
| `toolInput` | Arguments supplied when the tool was invoked |
| `toolOutput` | Your `structuredContent` - keep fields concise; the model reads them verbatim |
| `toolResponseMetadata` | The `_meta` payload; only the widget sees it, never the model |
| `widgetState` | Snapshot of UI state persisted between renders |

**Runtime APIs:**
| Method | Description |
|--------|-------------|
| `setWidgetState(state)` | Stores a new snapshot synchronously; call after every meaningful UI interaction |
| `callTool(name, args)` | Invoke another MCP tool from the widget |
| `sendFollowUpMessage({ prompt })` | Insert a user-authored message into conversation flow |
| `requestDisplayMode({ mode })` | Request layout changes (inline, pip, fullscreen) |
| `requestModal(...)` | Spawn a modal owned by ChatGPT |
| `notifyIntrinsicHeight(...)` | Report dynamic widget heights to avoid scroll clipping |
| `openExternal({ href })` | Open a vetted external link in the user's browser |

**Context Properties:**
| Property | Description |
|----------|-------------|
| `theme` | Current theme ("light" or "dark") |
| `displayMode` | Current display mode |
| `maxHeight` | Maximum height constraint (used in PiP mode, ~480px) |
| `locale` | User's locale setting |
| `userAgent` | Browser user agent |

### Display Modes

The Apps SDK supports three display modes, accessible via `requestDisplayMode`:

| Mode | Description | Use Case |
|------|-------------|----------|
| **Inline** | Appears directly in conversation flow | Default, quick confirmations, simple data |
| **Picture-in-Picture (PiP)** | Persistent floating window above conversation | Live sessions, games, **timers** |
| **Fullscreen** | Maximum screen real estate | Multi-step workflows, detailed content |

**Inline Mode (Default - Our Approach):**
- Widget appears directly in conversation flow
- Height matches content (tested up to 20k pixels)
- No special request needed - this is the default
- Widget persists in the message where it was created
- User can scroll up to see the timer anytime

**PiP Mode (Optional):**
- Creates floating window above conversation
- Maximum height constraint of ~480px applies
- **Not supported on mobile** - automatically coerces to fullscreen
- Request via: `window.openai.requestDisplayMode({ mode: "pip" })`

### Widget State Management

Widget state is **message-scoped** - each widget instance persists as long as its message exists in the conversation. The SDK provides three state categories:

1. **Business Data (Authoritative)** - Owned by MCP server; widget receives updated snapshots after tool calls
2. **UI State (Ephemeral)** - Managed within widget via `widgetState`; includes visual preferences, selected items
3. **Cross-Session State (Durable)** - Stored in your backend; preserves preferences across conversations

**Key Constraints:**
- State is scoped to the specific widget instance on a single conversation message
- Follow-up turns keep the same widget only when user submits through that widget's controls
- If user types into main chat composer, a new widget instance is created with empty state
- Keep payload well under 4k tokens for performance

### structuredContent and Tool Responses

When your MCP tool is called, it returns a response with three key parts:

```typescript
return {
  content: [{
    type: "text",
    text: "Human-readable description for the model"
  }],
  structuredContent: {
    // Concise data for both model AND widget
    // Keep fields minimal - model reads them verbatim
    type: "pomodoro",
    minutes: 25,
    endTime: 1735862400000
  },
  _meta: {
    // Sensitive/large data for widget ONLY (model never sees this)
    "openai/outputTemplate": "/widget/app.html"
  }
};
```

**Important:** Only `structuredContent` and `content` appear in the conversation transcript. The `_meta` payload is forwarded to the widget but hidden from the model.

---

## Widget Hosting and Delivery

### The text/html+skybridge MIME Type

Each UI bundle must be exposed as an MCP resource with MIME type `text/html+skybridge`. This signals to ChatGPT that:
- The payload is a sandboxed HTML entry point
- ChatGPT should inject the widget runtime (`window.openai`)
- The content should be treated as a widget template, not generic HTML

Without `text/html+skybridge`, ChatGPT won't render the template as a widget.

### How Widgets are Served

Widgets can be served in two ways:

**Option A: Inline HTML Content (Our Approach)**
The MCP server reads the HTML file and registers it directly:
```javascript
const widgetHtml = readFileSync("dist/widget/app.html", "utf8");
server.registerResource("widget://app", widgetHtml, "text/html+skybridge");
```

**Option B: External URL**
The tool's `_meta.openai/outputTemplate` points to an HTTPS URL where the widget is hosted.

### Build and Compilation Requirements

**Key Constraint:** ChatGPT enforces that widgets are **client-side single-page applications**. You cannot render dynamic HTML server-side - it must be static as it is cached once when the ChatGPT app is installed.

**For Vanilla HTML (Our Approach):**
- No build step required
- JavaScript runs directly in the browser
- All code must be client-side

**For Framework-based Apps (React, etc.):**
- Must be compiled/bundled before serving
- Use esbuild, Vite, or similar: `esbuild src/component.tsx --bundle --format=esm --outfile=dist/component.js`
- The compiled output is inlined into the HTML template

**Our Current Setup:**
```
src/
  server/index.ts     ← MCP server (compiled to JS)
  widget/index.tsx    ← Widget source (compiled to JS)
dist/
  widget/
    app.html          ← Static HTML served to ChatGPT
    app.js            ← Compiled widget JavaScript
```

### Production Deployment

For production, deploy to a low-latency HTTPS host:
- Cloudflare Workers
- Fly.io
- Vercel
- AWS (Lambda@Edge, CloudFront)

During development, use ngrok to tunnel localhost:
```bash
ngrok http 8000
# Then add the ngrok URL + /mcp as a connector in ChatGPT
```

---

## Real-Time Updates and Timers

### Using setInterval in Widgets

Since widgets run in standard iframes with full browser API access, JavaScript timers work normally:

```javascript
// This works perfectly in ChatGPT widgets
setInterval(() => {
  updateTimerDisplay();
  saveState();
}, 1000);
```

**Best Practices for Timer Widgets:**
1. Store `endTime` timestamp rather than remaining time (survives page refresh)
2. Save state to `widgetState` on each tick for persistence
3. Use `requestAnimationFrame` for smooth visual animations
4. Handle pause by storing `pausedRemaining` milliseconds

### State Persistence for Timers

```javascript
// On each timer tick
window.openai?.setWidgetState({
  endTime: state.endTime,
  isPaused: state.isPaused,
  pausedRemaining: state.pausedRemaining,
  label: state.label,
  completed: state.completed
});

// On widget mount - check for saved state
const savedState = window.openai?.widgetState;
if (savedState?.endTime && !savedState.completed) {
  restoreTimer(savedState);
}
```

---

## Why This Demo?

This is an ideal demonstration because:
1. **Truly visual** - A countdown timer with circular progress is inherently visual, not text-based
2. **Real-time updates** - Uses `setInterval` to show live countdown (showcases dynamic widgets)
3. **Inline display** - Timer appears directly in conversation, always accessible by scrolling
4. **State persistence** - Timer state survives across interactions via `widgetState`
5. **User interaction** - Pause/resume/reset buttons demonstrate interactive widgets
6. **Completion notification** - Widget can trigger follow-up message when timer ends

## Research Findings

### Widget Capabilities for Timers

Based on [OpenAI Apps SDK documentation](https://developers.openai.com/apps-sdk/build/chatgpt-ui/):

1. **JavaScript Timers Work**: Widgets run in standard iframes with full browser API access. `setInterval` and `requestAnimationFrame` work normally.

2. **PiP Display Mode**: Perfect for timers - creates a floating window above the conversation.
   - Request via: `window.openai.requestDisplayMode({ mode: "pip" })`
   - Uses `window.openai.maxHeight` for size constraints (~480px max)
   - Falls back to fullscreen on mobile

3. **State Persistence**: Critical for timers that might span multiple conversation turns.
   - Save: `window.openai.setWidgetState({ endTime, isPaused, duration })`
   - Restore: `window.openai.widgetState`

4. **Completion Notification**: Widget can notify ChatGPT when timer ends.
   - Via: `window.openai.sendFollowUpMessage({ prompt: "Timer complete!" })`

### Architecture

```
User: "25 minute timer"
         ↓
ChatGPT calls start_pomodoro({ minutes: 25 })
         ↓
MCP Server returns structuredContent with timer config
         ↓
Widget renders in PiP mode with circular countdown
         ↓
Widget uses setInterval for live updates
         ↓
Widget saves state to widgetState for persistence
         ↓
On completion: sendFollowUpMessage triggers ChatGPT notification
```

## Technical Design

### MCP Tool: `start_pomodoro`

```typescript
server.tool(
  "start_pomodoro",
  "Start a visual Pomodoro focus timer. Returns a countdown widget.",
  {
    minutes: z.number().min(1).max(120).describe("Duration in minutes (1-120)"),
    label: z.string().optional().describe("Optional label for this session (e.g., 'Deep work', 'Study')")
  },
  async ({ minutes, label }) => {
    const endTime = Date.now() + minutes * 60 * 1000;

    return {
      content: [{
        type: "text",
        text: `Pomodoro timer started: ${minutes} minutes${label ? ` (${label})` : ''}. Focus time!`
      }],
      structuredContent: {
        type: "pomodoro",
        minutes: minutes,
        endTime: endTime,
        label: label || "Focus Session",
        startedAt: new Date().toISOString()
      },
      _meta: {
        "openai/outputTemplate": { url: "https://your-widget-url/app.html" }
      }
    };
  }
);
```

### Widget Component: Pomodoro Timer

The widget needs to:
1. Parse `structuredContent` to get timer configuration
2. Request PiP display mode for persistent visibility
3. Run a countdown using `setInterval`
4. Display circular progress with time remaining
5. Provide pause/resume/reset controls
6. Save state to `widgetState` for persistence
7. Send follow-up message on completion

### Widget UI Design

```
┌─────────────────────────────────┐
│         Focus Session           │
│                                 │
│     ╭───────────────────╮       │
│     │                   │       │
│     │      23:45        │       │  ← Circular progress ring
│     │     remaining     │       │
│     │                   │       │
│     ╰───────────────────╯       │
│                                 │
│   [ Pause ]  [ Reset ]  [ +5 ]  │  ← Control buttons
│                                 │
│   Started at 2:30 PM            │
└─────────────────────────────────┘
```

### Key Implementation Details

#### 1. Timer State Management

```typescript
interface PomodoroState {
  endTime: number;        // Unix timestamp when timer ends
  isPaused: boolean;      // Is timer currently paused?
  pausedRemaining: number; // ms remaining when paused
  label: string;          // Session label
  completed: boolean;     // Has timer finished?
}

// On mount: restore from widgetState or use toolOutput
const savedState = window.openai?.widgetState as PomodoroState;
const toolData = window.openai?.toolOutput?.structuredContent;

if (savedState?.endTime && !savedState.completed) {
  // Resume existing timer
  restoreTimer(savedState);
} else if (toolData?.type === 'pomodoro') {
  // Start new timer
  startNewTimer(toolData);
}
```

#### 2. Request PiP Mode

```typescript
// Request PiP on mount for persistent visibility
async function requestPiP() {
  try {
    await window.openai?.requestDisplayMode?.({ mode: 'pip' });
  } catch (e) {
    // Falls back to inline or fullscreen on mobile
    console.log('PiP not available, using default mode');
  }
}
```

#### 3. Countdown Logic

```typescript
function startCountdown() {
  const intervalId = setInterval(() => {
    if (state.isPaused) return;

    const remaining = state.endTime - Date.now();

    if (remaining <= 0) {
      // Timer complete!
      clearInterval(intervalId);
      state.completed = true;
      playCompletionSound();
      notifyChatGPT();
      saveState();
      render();
    } else {
      // Update display
      saveState(); // Persist in case of page refresh
      render();
    }
  }, 1000);
}

function notifyChatGPT() {
  window.openai?.sendFollowUpMessage?.({
    prompt: `My ${state.label} timer just finished! What should I do for my break?`
  });
}
```

#### 4. Circular Progress Ring (SVG)

```typescript
function renderProgressRing(remaining: number, total: number): string {
  const progress = remaining / total;
  const circumference = 2 * Math.PI * 45; // r=45
  const offset = circumference * (1 - progress);

  return `
    <svg width="200" height="200" viewBox="0 0 100 100">
      <!-- Background circle -->
      <circle cx="50" cy="50" r="45"
              fill="none"
              stroke="var(--border)"
              stroke-width="8"/>
      <!-- Progress arc -->
      <circle cx="50" cy="50" r="45"
              fill="none"
              stroke="var(--accent)"
              stroke-width="8"
              stroke-linecap="round"
              stroke-dasharray="${circumference}"
              stroke-dashoffset="${offset}"
              transform="rotate(-90 50 50)"/>
    </svg>
  `;
}
```

#### 5. Time Formatting

```typescript
function formatTime(ms: number): string {
  const totalSeconds = Math.max(0, Math.ceil(ms / 1000));
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}
```

## Files to Modify

### 1. `src/server/index.ts`
- Add `start_pomodoro` tool
- Return structuredContent with timer configuration

### 2. `src/widget/index.tsx`
- Add `renderPomodoro()` function
- Add timer state management
- Add circular progress SVG component
- Add pause/resume/reset button handlers
- Add PiP mode request
- Add completion notification via `sendFollowUpMessage`

### 3. `dist/widget/app.html`
- Mirror TypeScript changes for direct testing

### 4. `dist/widget/test.html`
- Add "Start Pomodoro" simulation button
- Add controls to simulate pause/resume

## Implementation Steps

### Step 1: Add MCP Tool
Add `start_pomodoro` tool to server with minutes and label parameters.

### Step 2: Add Widget Rendering
- Add pomodoro styles (circular progress, control buttons)
- Add `renderPomodoro()` function
- Add time formatting utilities

### Step 3: Add Timer Logic
- Implement `setInterval` countdown
- Add pause/resume state management
- Save state to `widgetState`

### Step 4: Add PiP Mode
- Request PiP display mode on pomodoro type
- Handle fallback for mobile

### Step 5: Add Completion Flow
- Play subtle sound (optional)
- Send follow-up message to ChatGPT
- Show completion state UI

### Step 6: Update Test Page
- Add pomodoro simulation buttons
- Test state persistence

## Edge Cases to Handle

1. **Timer spans page refresh**: Use `widgetState` to restore timer
2. **User pauses timer**: Save `pausedRemaining` instead of `endTime`
3. **Timer ends while widget not visible**: Notification via `sendFollowUpMessage`
4. **Mobile devices**: PiP coerces to fullscreen (acceptable)
5. **Multiple timers**: Only one active timer per widget instance

## Testing Checklist

- [ ] Timer counts down accurately
- [ ] Circular progress animates smoothly
- [ ] Pause/resume works correctly
- [ ] State persists across widget updates
- [ ] PiP mode activates (desktop only)
- [ ] Completion notification triggers ChatGPT follow-up
- [ ] Light/dark theme works
- [ ] Test page simulates all states

## Sample Prompts to Test

- "Start a 25 minute pomodoro timer"
- "Set a focus timer for 5 minutes"
- "Start a 45 minute deep work session"
- "Pomodoro for 1 minute" (quick test)

## Future Enhancements (Out of Scope)

- Break timer recommendations
- Session history tracking
- Custom sounds
- Productivity stats
- Calendar integration

---

## Implementation Log

This section documents the implementation process and debugging attempts for future reference.

### Initial Implementation (Completed)

**Server Changes (`src/server/index.ts`):**
- Added `start_pomodoro` tool with `minutes` and `label` parameters
- Returns `structuredContent` with type: "pomodoro", minutes, durationMs, endTime, label, startedAt
- Registered widget resource with MIME type `text/html+skybridge`

**Widget Changes (`src/widget/index.tsx` and `dist/widget/app.html`):**
- Added Pomodoro styles (circular progress ring, timer display, control buttons)
- Added `renderPomodoro()` function with SVG circular progress
- Added `formatPomodoroTime()` for MM:SS display
- Added pause/resume/reset button handlers
- Added timer interval management with `setInterval`
- Added state persistence via `window.openai.setWidgetState()`

**Test Page Changes (`dist/widget/test.html`):**
- Added Pomodoro simulation buttons (1 min test, 25 min, completed state)
- Works correctly in local testing

### Issue #1: TypeScript Compilation Error

**Error:** `Property 'requestDisplayMode' does not exist on type 'OpenAIWidgetAPI'`

**Solution:** Added `requestDisplayMode` to the TypeScript interface:
```typescript
requestDisplayMode?: (opts: { mode: string }) => Promise<void>;
```

### Issue #2: PiP Mode Not Visible

**Problem:** After implementing PiP mode, user couldn't see the floating timer widget.

**Investigation:** PiP mode may have restrictions or not be available in all contexts.

**Solution:** Switched to inline mode (default) - widget appears directly in conversation. User can scroll up to see the timer. Removed `requestDisplayMode` call from widget initialization.

### Issue #3: Tool Blocked in ChatGPT

**Problem:** The Pomodoro tool was being blocked when invoked in ChatGPT.

**Investigation:** The widget wasn't using the correct MIME type for ChatGPT to recognize it.

**Solution:** Changed MIME type from `text/html` to `text/html+skybridge`:
```javascript
server.registerResource(
  "app-widget",
  WIDGET_RESOURCE_URI,
  {},
  async () => ({
    contents: [{
      uri: WIDGET_RESOURCE_URI,
      mimeType: "text/html+skybridge",  // Changed from "text/html"
      text: getWidgetHtml(),
    }],
  })
);
```

### Issue #4: Widget Not Showing After Tool Executes

**Problem:** Tool executes successfully (text response appears) but no widget iframe is rendered.

**Investigation:** May be related to how `_meta.openai/outputTemplate` is specified.

**Solution Attempt 1:** Changed from deprecated `server.tool()` to `server.registerTool()` with `_meta` in the tool definition config:
```javascript
server.registerTool(
  "start_pomodoro",
  {
    description: "...",
    inputSchema: { ... },
    _meta: {
      "openai/outputTemplate": WIDGET_RESOURCE_URI,
      "openai/toolInvocation/invoking": "Starting timer...",
      "openai/toolInvocation/invoked": "Timer started!",
    },
  },
  async ({ minutes, label }) => {
    return {
      content: [...],
      structuredContent: { ... },
      // Note: _meta NOT included in response at this point
    };
  }
);
```

### Issue #5: Widget Shows Wrong Content

**Problem:** Widget iframe renders, but shows "Hello World App is ready!" or the sales dashboard instead of the Pomodoro timer. The `structuredContent` is not reaching `window.openai.toolOutput.structuredContent`.

**Symptoms:**
- All tools (say_hello, get_random_fact, start_pomodoro, get_sales_dashboard) show the same widget UI
- Widget falls back to `renderNoData()` because `structuredContent` is undefined
- Text content from tools appears correctly (e.g., "Pomodoro timer started: 2 minutes")

**Solution Attempt 2:** Added cache-busting version to resource URI:
```javascript
const WIDGET_RESOURCE_URI = "ui://widget/app-v2.html";
```
**Result:** Still shows wrong content.

### Current Hypothesis (Issue #5 Ongoing)

Based on official OpenAI Apps SDK examples (`kitchen_sink.js`), the `_meta` object with `openai/outputTemplate` may need to be included in **BOTH**:

1. The tool definition config (for ChatGPT to know which template to use)
2. The tool response (for the data to be properly passed to the widget)

**Evidence from official kitchen_sink example:**
```javascript
// In tool definition
_meta: toolInvocationMeta("kitchen-sink-show"),

// In tool response
return {
  content: [{ type: "text", text: ... }],
  structuredContent: { ...payload, processedAt, echoed },
  _meta: toolInvocationMeta("kitchen-sink-show"),  // ALSO in response
};
```

**Where `toolInvocationMeta` is:**
```javascript
function toolInvocationMeta(toolName) {
  return {
    "openai/outputTemplate": WIDGET_RESOURCE_URI,
    "openai/toolInvocation/invoking": `${toolName}...`,
    "openai/toolInvocation/invoked": `${toolName} complete`,
  };
}
```

### Solution Attempt 3: Add `_meta` to Tool Responses (Applied)

Based on official examples, added `_meta` with `openai/outputTemplate` to **all tool responses** in addition to tool definitions:

```javascript
// Helper function (matches official examples pattern)
function toolMeta() {
  return {
    "openai/outputTemplate": WIDGET_RESOURCE_URI,
  };
}

// In each tool's return statement
return {
  content: [...],
  structuredContent: { ... },
  _meta: toolMeta(),  // Added to response
};
```

Applied to all 8 tools: say_hello, get_random_fact, calculate, get_time, get_sales_dashboard, get_sales_by_region, get_top_products, start_pomodoro.

**Status:** Did not fix the issue. Still shows "Hello World App is ready!" fallback.

### Solution Attempt 4: Research - Understanding toolOutput Structure

Researched official documentation to understand how `window.openai.toolOutput` works:

**From [Build your MCP server](https://developers.openai.com/apps-sdk/build/mcp-server/):**
- `openai/outputTemplate` is specified in the **tool definition** `_meta`, not the response
- Tool responses return `structuredContent`, `content`, and optionally `_meta` (for widget-only data)
- The `_meta` in the response is for **additional data** the widget needs, NOT for re-specifying the template

**From [Build your ChatGPT UI](https://developers.openai.com/apps-sdk/build/chatgpt-ui/):**
- `window.openai.toolOutput` contains "Your `structuredContent`"
- Documentation is ambiguous about whether `toolOutput` IS the structuredContent or CONTAINS it

**Current Widget Code:**
```javascript
const structuredContent = openai?.toolOutput?.structuredContent;
```

**Possible Issue:** Maybe `toolOutput` IS the structuredContent directly, not `toolOutput.structuredContent`.

**Observation:** The widget renders but always shows the fallback. This means:
1. ChatGPT IS loading the widget template (outputTemplate works)
2. ChatGPT IS passing `window.openai` to the widget
3. But `structuredContent` is empty/undefined when widget reads it

**Next Investigation:** Check if `toolOutput` directly contains the data, or if there's a timing issue where the widget renders before `toolOutput` is populated.

### Solution Attempt 5: Fix toolOutput Data Path (Applied)

**Root Cause Identified:** The widget was accessing `window.openai.toolOutput.structuredContent`, but according to the SDK documentation, `toolOutput` **IS** the structuredContent directly - not an object containing it.

**The Fix:**

Changed in `dist/widget/app.html` (line 1289) and `src/widget/index.tsx` (line 1340):

```javascript
// BEFORE (incorrect):
const structuredContent = openai?.toolOutput?.structuredContent;

// AFTER (correct):
const structuredContent = openai?.toolOutput;
```

Also updated the TypeScript interface to reflect the correct type:

```typescript
// BEFORE:
toolOutput?: {
  content?: Array<{ type: string; text?: string }>;
  structuredContent?: Record<string, unknown>;
};

// AFTER:
toolOutput?: Record<string, unknown>;
```

**Status:** Fix applied. Rebuild completed. Ready to test in ChatGPT.

### Environment Notes

- MCP Server: Node.js with Express, using `@modelcontextprotocol/sdk`
- Widget: Self-contained HTML with inline CSS and JavaScript
- Tunnel: ngrok for local development
- ChatGPT: Using the ChatGPT Apps connector feature

### Files Modified

| File | Changes |
|------|---------|
| `src/server/index.ts` | Added `start_pomodoro` tool, changed to `registerTool`, updated MIME type, added versioned URI |
| `src/widget/index.tsx` | Added Pomodoro rendering, styles, state management |
| `dist/widget/app.html` | Mirrored TypeScript changes for direct serving |
| `dist/widget/test.html` | Added Pomodoro simulation buttons |

---

## Sources

### Official Documentation
- [Apps SDK Overview](https://developers.openai.com/apps-sdk/) - Main documentation hub
- [Build your ChatGPT UI](https://developers.openai.com/apps-sdk/build/chatgpt-ui/) - Widget API reference, window.openai documentation
- [Build your MCP Server](https://developers.openai.com/apps-sdk/build/mcp-server/) - Tool creation, structuredContent, outputTemplate
- [Apps SDK Reference](https://developers.openai.com/apps-sdk/reference/) - File upload APIs, complete API reference
- [Managing State in ChatGPT Apps](https://developers.openai.com/apps-sdk/build/state-management/) - Widget state, persistence patterns
- [UI Guidelines](https://developers.openai.com/apps-sdk/concepts/ui-guidelines/) - Design principles, display modes, accessibility
- [Quickstart](https://developers.openai.com/apps-sdk/quickstart/) - Project structure, basic setup

### Example Code & Resources
- [OpenAI Apps SDK Examples](https://github.com/openai/openai-apps-sdk-examples) - Official sample implementations (Pizzaz, Kitchen Sink, Shopping Cart)
- [Apps SDK UI Kit](https://github.com/openai/apps-sdk-ui) - Optional React component library for consistent styling

### Community Resources
- [ChatGPT App Display Mode Reference](https://dev.to/abewheeler/chatgpt-app-display-mode-reference-49im) - Detailed PiP/fullscreen technical details, maxHeight constraints
- [Introducing Apps in ChatGPT](https://openai.com/index/introducing-apps-in-chatgpt/) - Official announcement, September 2025

### Key Concepts Referenced
- **text/html+skybridge** - MIME type that signals ChatGPT to treat HTML as a widget template
- **window.openai** - Injected API bridge for widget-to-ChatGPT communication
- **structuredContent** - Tool response data visible to both model and widget
- **_meta.openai/outputTemplate** - Metadata specifying which widget template to render
- **widgetState** - Persistent UI state scoped to widget instance
