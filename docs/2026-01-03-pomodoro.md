# Pomodoro Timer Widget - Implementation Plan

## Overview

Build a **visual Pomodoro timer widget** that showcases the core purpose of ChatGPT widgets: providing rich, interactive UI experiences beyond plain text responses.

### User Flow
1. User: "Start a pomodoro timer"
2. ChatGPT: "How many minutes would you like for your focus session?"
3. User: "25 minutes"
4. ChatGPT: Calls `start_pomodoro` tool → Widget displays visual countdown timer in PiP mode

---

## Background: ChatGPT Apps SDK

### What is the Apps SDK?

The [OpenAI Apps SDK](https://developers.openai.com/apps-sdk/) enables developers to extend ChatGPT with custom tools and rich UI components. Announced in September 2025, it builds on the **Model Context Protocol (MCP)**, the open standard that lets ChatGPT connect to external tools and data.

The Apps SDK extends MCP so developers can design both the **logic** (tools, data processing) and **interface** (widgets, visual components) of their apps. OpenAI has made the Apps SDK open source so that apps built with it can run anywhere that adopts this standard.

### Two-Component Architecture

To build an app for ChatGPT with the Apps SDK, you need two components:

1. **MCP Server** - Exposes your app's capabilities (tools) to ChatGPT using the Model Context Protocol. This is where you define what actions ChatGPT can take (e.g., `start_pomodoro`, `get_sales_dashboard`).

2. **Widget (Web Component)** - A web interface built with any framework (React, vanilla JS, etc.) that renders in an iframe within the ChatGPT interface. This displays your app's output and handles user interactions.

```
┌─────────────────────────────────────────────────────────────────┐
│                         ChatGPT                                  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    Conversation                            │  │
│  │  User: "Start a 25 minute timer"                          │  │
│  │                                                            │  │
│  │  ChatGPT: Calls start_pomodoro tool                       │  │
│  │           ↓                                                │  │
│  │  ┌─────────────────────────────────┐                      │  │
│  │  │     Widget (iframe)              │  ← Your UI          │  │
│  │  │     ┌─────────────────────┐     │                      │  │
│  │  │     │    Pomodoro Timer   │     │                      │  │
│  │  │     │       23:45         │     │                      │  │
│  │  │     └─────────────────────┘     │                      │  │
│  │  └─────────────────────────────────┘                      │  │
│  └───────────────────────────────────────────────────────────┘  │
│                              ↕                                   │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              MCP Server (your backend)                     │  │
│  │   Tools: start_pomodoro, get_sales_dashboard, etc.        │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### The window.openai API

When ChatGPT loads your widget in an iframe, it injects a `window.openai` object that serves as the bridge between your frontend and ChatGPT. This API provides:

**State & Data:**
| Property | Description |
|----------|-------------|
| `toolInput` | Arguments supplied when the tool was invoked |
| `toolOutput` | Your `structuredContent` - keep fields concise; the model reads them verbatim |
| `toolResponseMetadata` | The `_meta` payload; only the widget sees it, never the model |
| `widgetState` | Snapshot of UI state persisted between renders |

**Runtime APIs:**
| Method | Description |
|--------|-------------|
| `setWidgetState(state)` | Stores a new snapshot synchronously; call after every meaningful UI interaction |
| `callTool(name, args)` | Invoke another MCP tool from the widget |
| `sendFollowUpMessage({ prompt })` | Insert a user-authored message into conversation flow |
| `requestDisplayMode({ mode })` | Request layout changes (inline, pip, fullscreen) |
| `requestModal(...)` | Spawn a modal owned by ChatGPT |
| `notifyIntrinsicHeight(...)` | Report dynamic widget heights to avoid scroll clipping |
| `openExternal({ href })` | Open a vetted external link in the user's browser |

**Context Properties:**
| Property | Description |
|----------|-------------|
| `theme` | Current theme ("light" or "dark") |
| `displayMode` | Current display mode |
| `maxHeight` | Maximum height constraint (used in PiP mode, ~480px) |
| `locale` | User's locale setting |
| `userAgent` | Browser user agent |

### Display Modes

The Apps SDK supports three display modes, accessible via `requestDisplayMode`:

| Mode | Description | Use Case |
|------|-------------|----------|
| **Inline** | Appears directly in conversation flow | Default, quick confirmations, simple data |
| **Picture-in-Picture (PiP)** | Persistent floating window above conversation | Live sessions, games, **timers** |
| **Fullscreen** | Maximum screen real estate | Multi-step workflows, detailed content |

**PiP Mode Details:**
- Perfect for our Pomodoro timer - remains visible while user continues chatting
- Maximum height constraint of ~480px applies
- Content becomes scrollable beyond maxHeight limit
- **Not supported on mobile** - automatically coerces to fullscreen
- Request via: `window.openai.requestDisplayMode({ mode: "pip" })`

### Widget State Management

Widget state is **message-scoped** - each widget instance persists as long as its message exists in the conversation. The SDK provides three state categories:

1. **Business Data (Authoritative)** - Owned by MCP server; widget receives updated snapshots after tool calls
2. **UI State (Ephemeral)** - Managed within widget via `widgetState`; includes visual preferences, selected items
3. **Cross-Session State (Durable)** - Stored in your backend; preserves preferences across conversations

**Key Constraints:**
- State is scoped to the specific widget instance on a single conversation message
- Follow-up turns keep the same widget only when user submits through that widget's controls
- If user types into main chat composer, a new widget instance is created with empty state
- Keep payload well under 4k tokens for performance

### structuredContent and Tool Responses

When your MCP tool is called, it returns a response with three key parts:

```typescript
return {
  content: [{
    type: "text",
    text: "Human-readable description for the model"
  }],
  structuredContent: {
    // Concise data for both model AND widget
    // Keep fields minimal - model reads them verbatim
    type: "pomodoro",
    minutes: 25,
    endTime: 1735862400000
  },
  _meta: {
    // Sensitive/large data for widget ONLY (model never sees this)
    "openai/outputTemplate": "/widget/app.html"
  }
};
```

**Important:** Only `structuredContent` and `content` appear in the conversation transcript. The `_meta` payload is forwarded to the widget but hidden from the model.

---

## Widget Hosting and Delivery

### The text/html+skybridge MIME Type

Each UI bundle must be exposed as an MCP resource with MIME type `text/html+skybridge`. This signals to ChatGPT that:
- The payload is a sandboxed HTML entry point
- ChatGPT should inject the widget runtime (`window.openai`)
- The content should be treated as a widget template, not generic HTML

Without `text/html+skybridge`, ChatGPT won't render the template as a widget.

### How Widgets are Served

Widgets can be served in two ways:

**Option A: Inline HTML Content (Our Approach)**
The MCP server reads the HTML file and registers it directly:
```javascript
const widgetHtml = readFileSync("dist/widget/app.html", "utf8");
server.registerResource("widget://app", widgetHtml, "text/html+skybridge");
```

**Option B: External URL**
The tool's `_meta.openai/outputTemplate` points to an HTTPS URL where the widget is hosted.

### Build and Compilation Requirements

**Key Constraint:** ChatGPT enforces that widgets are **client-side single-page applications**. You cannot render dynamic HTML server-side - it must be static as it is cached once when the ChatGPT app is installed.

**For Vanilla HTML (Our Approach):**
- No build step required
- JavaScript runs directly in the browser
- All code must be client-side

**For Framework-based Apps (React, etc.):**
- Must be compiled/bundled before serving
- Use esbuild, Vite, or similar: `esbuild src/component.tsx --bundle --format=esm --outfile=dist/component.js`
- The compiled output is inlined into the HTML template

**Our Current Setup:**
```
src/
  server/index.ts     ← MCP server (compiled to JS)
  widget/index.tsx    ← Widget source (compiled to JS)
dist/
  widget/
    app.html          ← Static HTML served to ChatGPT
    app.js            ← Compiled widget JavaScript
```

### Production Deployment

For production, deploy to a low-latency HTTPS host:
- Cloudflare Workers
- Fly.io
- Vercel
- AWS (Lambda@Edge, CloudFront)

During development, use ngrok to tunnel localhost:
```bash
ngrok http 8000
# Then add the ngrok URL + /mcp as a connector in ChatGPT
```

---

## Real-Time Updates and Timers

### Using setInterval in Widgets

Since widgets run in standard iframes with full browser API access, JavaScript timers work normally:

```javascript
// This works perfectly in ChatGPT widgets
setInterval(() => {
  updateTimerDisplay();
  saveState();
}, 1000);
```

**Best Practices for Timer Widgets:**
1. Store `endTime` timestamp rather than remaining time (survives page refresh)
2. Save state to `widgetState` on each tick for persistence
3. Use `requestAnimationFrame` for smooth visual animations
4. Handle pause by storing `pausedRemaining` milliseconds

### State Persistence for Timers

```javascript
// On each timer tick
window.openai?.setWidgetState({
  endTime: state.endTime,
  isPaused: state.isPaused,
  pausedRemaining: state.pausedRemaining,
  label: state.label,
  completed: state.completed
});

// On widget mount - check for saved state
const savedState = window.openai?.widgetState;
if (savedState?.endTime && !savedState.completed) {
  restoreTimer(savedState);
}
```

---

## Why This Demo?

This is an ideal demonstration because:
1. **Truly visual** - A countdown timer with circular progress is inherently visual, not text-based
2. **Real-time updates** - Uses `setInterval` to show live countdown (showcases dynamic widgets)
3. **PiP mode** - Timer persists while user continues chatting (demonstrates display modes)
4. **State persistence** - Timer state survives across interactions via `widgetState`
5. **User interaction** - Pause/resume/reset buttons demonstrate interactive widgets
6. **Completion notification** - Widget can trigger follow-up message when timer ends

## Research Findings

### Widget Capabilities for Timers

Based on [OpenAI Apps SDK documentation](https://developers.openai.com/apps-sdk/build/chatgpt-ui/):

1. **JavaScript Timers Work**: Widgets run in standard iframes with full browser API access. `setInterval` and `requestAnimationFrame` work normally.

2. **PiP Display Mode**: Perfect for timers - creates a floating window above the conversation.
   - Request via: `window.openai.requestDisplayMode({ mode: "pip" })`
   - Uses `window.openai.maxHeight` for size constraints (~480px max)
   - Falls back to fullscreen on mobile

3. **State Persistence**: Critical for timers that might span multiple conversation turns.
   - Save: `window.openai.setWidgetState({ endTime, isPaused, duration })`
   - Restore: `window.openai.widgetState`

4. **Completion Notification**: Widget can notify ChatGPT when timer ends.
   - Via: `window.openai.sendFollowUpMessage({ prompt: "Timer complete!" })`

### Architecture

```
User: "25 minute timer"
         ↓
ChatGPT calls start_pomodoro({ minutes: 25 })
         ↓
MCP Server returns structuredContent with timer config
         ↓
Widget renders in PiP mode with circular countdown
         ↓
Widget uses setInterval for live updates
         ↓
Widget saves state to widgetState for persistence
         ↓
On completion: sendFollowUpMessage triggers ChatGPT notification
```

## Technical Design

### MCP Tool: `start_pomodoro`

```typescript
server.tool(
  "start_pomodoro",
  "Start a visual Pomodoro focus timer. Returns a countdown widget.",
  {
    minutes: z.number().min(1).max(120).describe("Duration in minutes (1-120)"),
    label: z.string().optional().describe("Optional label for this session (e.g., 'Deep work', 'Study')")
  },
  async ({ minutes, label }) => {
    const endTime = Date.now() + minutes * 60 * 1000;

    return {
      content: [{
        type: "text",
        text: `Pomodoro timer started: ${minutes} minutes${label ? ` (${label})` : ''}. Focus time!`
      }],
      structuredContent: {
        type: "pomodoro",
        minutes: minutes,
        endTime: endTime,
        label: label || "Focus Session",
        startedAt: new Date().toISOString()
      },
      _meta: {
        "openai/outputTemplate": { url: "https://your-widget-url/app.html" }
      }
    };
  }
);
```

### Widget Component: Pomodoro Timer

The widget needs to:
1. Parse `structuredContent` to get timer configuration
2. Request PiP display mode for persistent visibility
3. Run a countdown using `setInterval`
4. Display circular progress with time remaining
5. Provide pause/resume/reset controls
6. Save state to `widgetState` for persistence
7. Send follow-up message on completion

### Widget UI Design

```
┌─────────────────────────────────┐
│         Focus Session           │
│                                 │
│     ╭───────────────────╮       │
│     │                   │       │
│     │      23:45        │       │  ← Circular progress ring
│     │     remaining     │       │
│     │                   │       │
│     ╰───────────────────╯       │
│                                 │
│   [ Pause ]  [ Reset ]  [ +5 ]  │  ← Control buttons
│                                 │
│   Started at 2:30 PM            │
└─────────────────────────────────┘
```

### Key Implementation Details

#### 1. Timer State Management

```typescript
interface PomodoroState {
  endTime: number;        // Unix timestamp when timer ends
  isPaused: boolean;      // Is timer currently paused?
  pausedRemaining: number; // ms remaining when paused
  label: string;          // Session label
  completed: boolean;     // Has timer finished?
}

// On mount: restore from widgetState or use toolOutput
const savedState = window.openai?.widgetState as PomodoroState;
const toolData = window.openai?.toolOutput?.structuredContent;

if (savedState?.endTime && !savedState.completed) {
  // Resume existing timer
  restoreTimer(savedState);
} else if (toolData?.type === 'pomodoro') {
  // Start new timer
  startNewTimer(toolData);
}
```

#### 2. Request PiP Mode

```typescript
// Request PiP on mount for persistent visibility
async function requestPiP() {
  try {
    await window.openai?.requestDisplayMode?.({ mode: 'pip' });
  } catch (e) {
    // Falls back to inline or fullscreen on mobile
    console.log('PiP not available, using default mode');
  }
}
```

#### 3. Countdown Logic

```typescript
function startCountdown() {
  const intervalId = setInterval(() => {
    if (state.isPaused) return;

    const remaining = state.endTime - Date.now();

    if (remaining <= 0) {
      // Timer complete!
      clearInterval(intervalId);
      state.completed = true;
      playCompletionSound();
      notifyChatGPT();
      saveState();
      render();
    } else {
      // Update display
      saveState(); // Persist in case of page refresh
      render();
    }
  }, 1000);
}

function notifyChatGPT() {
  window.openai?.sendFollowUpMessage?.({
    prompt: `My ${state.label} timer just finished! What should I do for my break?`
  });
}
```

#### 4. Circular Progress Ring (SVG)

```typescript
function renderProgressRing(remaining: number, total: number): string {
  const progress = remaining / total;
  const circumference = 2 * Math.PI * 45; // r=45
  const offset = circumference * (1 - progress);

  return `
    <svg width="200" height="200" viewBox="0 0 100 100">
      <!-- Background circle -->
      <circle cx="50" cy="50" r="45"
              fill="none"
              stroke="var(--border)"
              stroke-width="8"/>
      <!-- Progress arc -->
      <circle cx="50" cy="50" r="45"
              fill="none"
              stroke="var(--accent)"
              stroke-width="8"
              stroke-linecap="round"
              stroke-dasharray="${circumference}"
              stroke-dashoffset="${offset}"
              transform="rotate(-90 50 50)"/>
    </svg>
  `;
}
```

#### 5. Time Formatting

```typescript
function formatTime(ms: number): string {
  const totalSeconds = Math.max(0, Math.ceil(ms / 1000));
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}
```

## Files to Modify

### 1. `src/server/index.ts`
- Add `start_pomodoro` tool
- Return structuredContent with timer configuration

### 2. `src/widget/index.tsx`
- Add `renderPomodoro()` function
- Add timer state management
- Add circular progress SVG component
- Add pause/resume/reset button handlers
- Add PiP mode request
- Add completion notification via `sendFollowUpMessage`

### 3. `dist/widget/app.html`
- Mirror TypeScript changes for direct testing

### 4. `dist/widget/test.html`
- Add "Start Pomodoro" simulation button
- Add controls to simulate pause/resume

## Implementation Steps

### Step 1: Add MCP Tool
Add `start_pomodoro` tool to server with minutes and label parameters.

### Step 2: Add Widget Rendering
- Add pomodoro styles (circular progress, control buttons)
- Add `renderPomodoro()` function
- Add time formatting utilities

### Step 3: Add Timer Logic
- Implement `setInterval` countdown
- Add pause/resume state management
- Save state to `widgetState`

### Step 4: Add PiP Mode
- Request PiP display mode on pomodoro type
- Handle fallback for mobile

### Step 5: Add Completion Flow
- Play subtle sound (optional)
- Send follow-up message to ChatGPT
- Show completion state UI

### Step 6: Update Test Page
- Add pomodoro simulation buttons
- Test state persistence

## Edge Cases to Handle

1. **Timer spans page refresh**: Use `widgetState` to restore timer
2. **User pauses timer**: Save `pausedRemaining` instead of `endTime`
3. **Timer ends while widget not visible**: Notification via `sendFollowUpMessage`
4. **Mobile devices**: PiP coerces to fullscreen (acceptable)
5. **Multiple timers**: Only one active timer per widget instance

## Testing Checklist

- [ ] Timer counts down accurately
- [ ] Circular progress animates smoothly
- [ ] Pause/resume works correctly
- [ ] State persists across widget updates
- [ ] PiP mode activates (desktop only)
- [ ] Completion notification triggers ChatGPT follow-up
- [ ] Light/dark theme works
- [ ] Test page simulates all states

## Sample Prompts to Test

- "Start a 25 minute pomodoro timer"
- "Set a focus timer for 5 minutes"
- "Start a 45 minute deep work session"
- "Pomodoro for 1 minute" (quick test)

## Future Enhancements (Out of Scope)

- Break timer recommendations
- Session history tracking
- Custom sounds
- Productivity stats
- Calendar integration

---

## Sources

### Official Documentation
- [Apps SDK Overview](https://developers.openai.com/apps-sdk/) - Main documentation hub
- [Build your ChatGPT UI](https://developers.openai.com/apps-sdk/build/chatgpt-ui/) - Widget API reference, window.openai documentation
- [Build your MCP Server](https://developers.openai.com/apps-sdk/build/mcp-server/) - Tool creation, structuredContent, outputTemplate
- [Apps SDK Reference](https://developers.openai.com/apps-sdk/reference/) - File upload APIs, complete API reference
- [Managing State in ChatGPT Apps](https://developers.openai.com/apps-sdk/build/state-management/) - Widget state, persistence patterns
- [UI Guidelines](https://developers.openai.com/apps-sdk/concepts/ui-guidelines/) - Design principles, display modes, accessibility
- [Quickstart](https://developers.openai.com/apps-sdk/quickstart/) - Project structure, basic setup

### Example Code & Resources
- [OpenAI Apps SDK Examples](https://github.com/openai/openai-apps-sdk-examples) - Official sample implementations (Pizzaz, Kitchen Sink, Shopping Cart)
- [Apps SDK UI Kit](https://github.com/openai/apps-sdk-ui) - Optional React component library for consistent styling

### Community Resources
- [ChatGPT App Display Mode Reference](https://dev.to/abewheeler/chatgpt-app-display-mode-reference-49im) - Detailed PiP/fullscreen technical details, maxHeight constraints
- [Introducing Apps in ChatGPT](https://openai.com/index/introducing-apps-in-chatgpt/) - Official announcement, September 2025

### Key Concepts Referenced
- **text/html+skybridge** - MIME type that signals ChatGPT to treat HTML as a widget template
- **window.openai** - Injected API bridge for widget-to-ChatGPT communication
- **structuredContent** - Tool response data visible to both model and widget
- **_meta.openai/outputTemplate** - Metadata specifying which widget template to render
- **widgetState** - Persistent UI state scoped to widget instance
